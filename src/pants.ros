#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -L sbcl -- $0 "$@"
|#

;;; COMPILE FLAGS
(declaim (sb-ext:muffle-conditions cl:style-warning))
(declaim (optimize (speed 3) (space 0) (debug 0) (safety 0) (compilation-speed 0)))
(declaim (sb-ext:muffle-conditions sb-ext:compiler-note))

;;; LOAD FLAGS
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf sb-impl::*default-external-format* :utf-8)
  (setf sb-alien::*default-c-string-external-format* :utf-8) 
  (setf *read-default-float-format* 'double-float))

;;; USE PACKAGES
(setf ql:*local-project-directories* (list "~/.roswell/local-projects/"))
(ql:quickload :jack-tools :silent t)
(ql:quickload :inferior-shell :silent t)
(ql:quickload :log4cl :silent t)
(ql:quickload :hunchentoot :silent t)

;;; MODIFY HUNCHENTOOT THREADING
(in-package :hunchentoot)
(defmethod start-thread ((taskmaster one-thread-per-connection-taskmaster) thunk &key name)
  "0. instantiate calling thread's current package
   1. pass initial special bindings to bordeaux threads
   2. pass initial special bindings to child threads"
  (let* ((package-name (package-name *package*)) 
	 (initial-bindings `((*package* . (find-package ,package-name)))))
    (bt:make-thread thunk :name name :initial-bindings initial-bindings)))

;;; PACKAGE DECLARATION -- DON'T CROSS IMPORT FILES
(in-package #:cl-user)
(defpackage #:jack.tools.pants
  (:use #:cl 
	#:hunchentoot
        #:cl-json
	#:jack.tools.lists
	#:jack.tools.keys
        #:jack.tools.misc
        #:jack.tools.withs
        #:jack.tools.objects))
(in-package #:jack.tools.pants)

;;; INITIALIZE KEYS
(defconstant +aes-key+ (create-id :size 32 :string? nil))
(let ((identifier (generate-pems "/Users/asclepius/")))
  (defconstant +public-key+ (parse-pem-file (format nil "/Users/asclepius/~d.public" identifier)))
  (defconstant +private-key+ (parse-pem-file (format nil "/Users/asclepius/~d.private" identifier))))

;;; HELP FILE
(defun main (port) 
  (cond ((inferior-shell:run/ss `(and (openssl -h)))
         (start (make-instance 'easy-acceptor :port (read-from-string port)))
         (define-easy-handler (pants/generate :uri "/pants/generate") ()
           (setf (content-type*) "application/json")
           (let* ((content (decode-json-from-string (raw-post-data :force-text t)))
                  (path (agethash :path content))
                  (id (write-to-string (generate-pems path)))
                  (private-path (format nil "~d~d.private" path id))) 
             (write-file (pants-on +aes-key+ +public-key+ (open-file private-path)) private-path) 
             (format nil "{\"fileID\": \"~d\"}" id)))
         
         (define-easy-handler (pants/sign :uri "/pants/sign") ()
           (setf (content-type*) "application/json")
           (let* ((content (decode-json-from-string (raw-post-data :force-text t)))
                  (path (agethash :path content))
                  (message (agethash :message content))
                  (private-path (format nil "~d.private" path))
                  (raw-key (pants-off +aes-key+ +private-key+ (open-file private-path) :string? nil))
                  (trim-key (cl-ppcre:split "\\n" raw-key))
                  (fit-key (trim-seq trim-key 1 (- (length trim-key) 1)))) 
             (format nil "{\"signature\": \"~d\"}"
                     (sign-message (pem/pkey::read-private-key
                                    (format nil "~{~d~}" fit-key))
                                   message))))

         (define-easy-handler (pants/verify :uri "/pants/verify") ()
           (setf (content-type*) "application/json")
           (let* ((content (decode-json-from-string (raw-post-data :force-text t)))
                  (path (agethash :path content))
                  (message (agethash :message content))
                  (signature (agethash :signature content)))
             (format nil "{\"verification\": \"~d\"}"
                     (verify-signature (parse-pem-file (format nil "~d.public" path))
                                       message signature))))
         
         (define-easy-handler (pants/get :uri "/pants/get") ()
           (setf (content-type*) "application/json")
           (let* ((content (decode-json-from-string (raw-post-data :force-text t)))
                  (path (agethash :path content)))
             (format nil "{\"pubKey\": \"~d\"}"
                     (parse-pem-file (format nil "~d.public" path)))))
         (format *standard-output* "Started server.~%")
         (handler-case
             (sb-thread:join-thread
              (find-if #'(lambda (thread) (search "hunchentoot" (sb-thread:thread-name thread)))
                       (sb-thread:list-all-threads)))
           (sb-sys:interactive-interrupt () (sb-ext:exit)))) 
        (t (log:info "OpenSSL is required."))))
